---
title: "mrr_project_bio"
author: ""
date: "2025-11-10"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Classification of Cancer outcome using Genetic and Clinical data

## Introduction

This project investigates the effect of genetic and clinical variables on the survival outcome of breast cancer patients. The data contains records of more than 1000 breast cancer patients from several research institutions. Clinical data contains patient-related and tumor-related information. Additionally mRNA gene expression data is available for each patient. The gene expression data has been processed to include only the top 5000 most variable genes on the transformed scale (log2(counts + 1)).

We consider that the main outcome variable of interest is **vital_status**, which is defined in clinical data.

## Load data

```{r}
load("mrr_bio.Rdata")
```

### Genes data

```{r}
dim(GeneX)
str(GeneX)
colnames(GeneX)[1:10]
rownames(GeneX)[1:10]
```

`GeneX` est un tableau de 1231 lignes par 5000 colonnes :

- Les lignes correspondent aux patients avec le nom de chaque ligne l'identifiant du patient comme `EW-A2FS-01A-11R-A17B`.
- Les colonnes correspondent aux gènes avec chaque nom de colonne un gène comme `CLEC3A`, qui sont les 5000 gènes les plus variables d'une personne à l'autre.
- Chaque case correspond à la valeur d'expression (un flottant) d'un certain gène (colonne) pour un certain patient (ligne) -> variables continues

### Clinical data

```{r}
load("mrr_bio.Rdata")
dim(clinical_data)
head(clinical_data[, 1:5])
colnames(clinical_data)
```

`clinical_data` est un tableau de 1231 lignes par 24 colonnes :

- Les lignes correspondent aux noms des patients comme pour `GeneX`.
- Les colonnes sont les noms des données cliniques, comme `initial_weight`, `sites_of_involvement` et `vital_status`.
- Chaque case correspond à la valeur de la donnée clinique pour chaque patient, donc ce peut être un entier ou une chaîne de caractères.

### Outcome variable

The outcome variable is the vital status of the patient (dead or alive) :
```{r}
y <- clinical_data$vital_status
table(y)

barplot(table(y),
        main = "Distribution of Vital Status",
        xlab = "Vital Status",
        ylab = "Frequency",
        col = c("lightblue", "salmon"))
```


## Exploratory data analysis

### Genes

### Clinical Data

Voici chaque type correspondant à chaque donnée ainsi que les fréquences de chaque occurrence : 

```{r}
for (col in colnames(clinical_data)) {
  cat("\n=== ", col, " ===\n", sep = "")
  current_col <- clinical_data[[col]]
  print(unique(current_col))

  if (is.atomic(current_col) || is.factor(current_col)) {
    print(table(as.vector(current_col), useNA = "ifany"))
  } else {
    cat("table() skipped: column is", class(current_col), "\n")
  }
}
```


Matrice de confusion :
```{r}
x <- clinical_data[, c("age_at_diagnosis",
                       "initial_weight",
                       "classification_of_tumor",
                       "morphology")]
y <- clinical_data$vital_status
model_data <- data.frame(x, vital_status = factor(y))
model_data <- na.omit(model_data) # retire les observations incomplètes
model_data$vital_status <- droplevels(model_data$vital_status)

# Modèle logistique
model <- glm(vital_status ~ ., data = model_data, family = binomial)

# Prédiction
pred <- predict(model, type = "response")
positive_class <- levels(model_data$vital_status)[2]
pred_class <- ifelse(pred > 0.5, positive_class, levels(model_data$vital_status)[1])
pred_class <- factor(pred_class, levels = levels(model_data$vital_status))

# Matrice de confusion sans caret
conf_mat <- table(Predicted = pred_class, Observed = model_data$vital_status)
conf_mat

# Indicateurs simples
accuracy <- sum(diag(conf_mat)) / sum(conf_mat)
cat(sprintf("\nAccuracy: %.3f\n", accuracy))

# Visualisation de la matrice de confusion
conf_mat_matrix <- as.matrix(conf_mat)
image(t(conf_mat_matrix[nrow(conf_mat_matrix):1, ]),
  axes = FALSE,
  col = colorRampPalette(c("#f7fbff", "#6baed6", "#08306b"))(64),
  xlab = "Observed",
  ylab = "Predicted",
  main = "Confusion Matrix")
axis(1, at = seq(0, 1, length.out = ncol(conf_mat_matrix)), labels = colnames(conf_mat_matrix))
axis(2, at = seq(0, 1, length.out = nrow(conf_mat_matrix)), labels = rev(rownames(conf_mat_matrix)))
text(rep(seq(0, 1, length.out = ncol(conf_mat_matrix)), each = nrow(conf_mat_matrix)),
     rep(seq(0, 1, length.out = nrow(conf_mat_matrix)), times = ncol(conf_mat_matrix)),
     labels = as.vector(conf_mat_matrix[rev(seq_len(nrow(conf_mat_matrix))), ]),
     col = "black", font = 2)
```

## Data analysis

But : prédire la donnée clinique vie/mort.
Donc on veut utiliser des modèles de classification : 
- KNN avec $k=2$
- kmeans avec $k=2$
- régression logistique
- groupe-lasso ?
- elastic net ?
- lasso, ridge ?
- stepwise

### Genes

Pour la tableau de gènes, traçons un premier plot pour chaque gène avec la distribution gaussienne de mort/vivant pour chaque gène. Ensuite nous pouvons prendre la moyenne de ce graphe.
Et ensuite tracer toutes les moyennes correspondant à chaque gène dans un graphe commun et vérifier lesquels varient fortement de la médiane (la médiane des moyennes)

Et ensuite LASSO pour réduire la dimension

### Clinical data